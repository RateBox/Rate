---
description: 
globs: 
alwaysApply: true
---
# MEMORY PATTERNS & KNOWLEDGE MANAGEMENT

## ğŸ§  MEMORY BANK AUTOMATION

### Tá»± Ä‘á»™ng Capture Knowledge
Khi AI encounter situations nÃ y, LUÃ”N update memory:

1. **Giáº£i quyáº¿t bug phá»©c táº¡p** â†’ Store solution pattern
2. **Discover project-specific quirks** â†’ Document trong rules
3. **Successful feature implementation** â†’ Save architecture decision
4. **Performance optimization** â†’ Record performance pattern
5. **Error resolution** â†’ Add to troubleshooting knowledge

### Knowledge Categories
```
ğŸ“ memory-bank/
â”œâ”€â”€ ğŸ”§ technical-patterns/
â”‚   â”œâ”€â”€ strapi-plugin-development.md
â”‚   â”œâ”€â”€ turborepo-optimization.md
â”‚   â””â”€â”€ powershell-automation.md
â”œâ”€â”€ ğŸ› bug-solutions/
â”‚   â”œâ”€â”€ mcp-server-crashes.md
â”‚   â”œâ”€â”€ strapi-build-errors.md
â”‚   â””â”€â”€ playwright-test-failures.md
â”œâ”€â”€ ğŸš€ successful-implementations/
â”‚   â”œâ”€â”€ smart-component-filter.md
â”‚   â”œâ”€â”€ authentication-flow.md
â”‚   â””â”€â”€ api-integration-patterns.md
â””â”€â”€ ğŸ“Š performance-insights/
    â”œâ”€â”€ build-optimization.md
    â”œâ”€â”€ database-query-tuning.md
    â””â”€â”€ frontend-bundle-analysis.md
```

## ğŸ”„ LEARNING LOOP PATTERNS

### After Every Major Task
```
AUTOMATIC ROUTINE:
1. Analyze what worked well
2. Identify what was challenging
3. Extract reusable patterns
4. Update relevant memory files
5. Enhance cursor rules if needed
```

### Pattern Recognition Triggers
- **Repetitive problems** â†’ Create automation script
- **Manual steps** â†’ Generate automation workflow  
- **Knowledge gaps** â†’ Request documentation
- **Successful solutions** â†’ Template for future use

## ğŸ“š KNOWLEDGE TEMPLATES

### Bug Resolution Template
```markdown
# [Bug Name] - [Date]

## Problem
- Symptoms: [what user observed]
- Root Cause: [technical cause]
- Impact: [what broke]

## Solution
```code
[exact solution code]
```

## Prevention
- [how to avoid in future]
- [detection methods]
- [monitoring to add]

## Related Patterns
- Similar issues: [links]
- Prevention strategies: [list]
```

### Feature Implementation Template
```markdown
# [Feature Name] - Implementation Pattern

## Architecture Decision
- Approach: [why this approach]
- Trade-offs: [what was considered]
- Dependencies: [what was needed]

## Code Pattern
```typescript
// Reusable pattern example
[key code snippets]
```

## Testing Strategy
- Unit tests: [approach]
- Integration tests: [coverage]
- E2E tests: [scenarios]

## Deployment Notes
- Build requirements: [list]
- Environment variables: [list]
- Post-deployment checks: [list]
```

## ğŸ¤– AI SELF-IMPROVEMENT

### Continuous Learning Prompts
```
END-OF-SESSION AUTOMATION:
"Analyze our conversation and identify:
1. New patterns worth remembering
2. Mistakes to avoid next time
3. Successful techniques to reuse
4. Updates needed for cursor rules
5. Memory bank additions required"
```

### Performance Tracking
Track vÃ  improve:
- **Code generation accuracy**
- **Bug resolution speed**  
- **Pattern recognition success**
- **Automation effectiveness**
- **User satisfaction levels**

## ğŸ“ˆ MEMORY OPTIMIZATION

### Regular Maintenance
- **Weekly**: Review vÃ  consolidate memories
- **Monthly**: Archive outdated patterns
- **Quarterly**: Optimize rule effectiveness
- **Yearly**: Major knowledge reorganization

### Memory Prioritization
1. **High Priority**: Frequently used patterns
2. **Medium Priority**: Project-specific knowledge
3. **Low Priority**: One-time solutions
4. **Archive**: Deprecated/outdated information

## ğŸ” PATTERN MATCHING

### Common Scenarios to Remember
- **MCP Server Issues** â†’ Auto-restart procedures
- **Strapi Plugin Problems** â†’ Version compatibility matrix
- **Build Failures** â†’ Common causes vÃ  fixes
- **Performance Issues** â†’ Optimization checklists
- **Deployment Problems** â†’ Rollback procedures

### Correlation Analysis
Connect patterns across:
- **Technology stacks** (Node.js + Strapi + Next.js)
- **Error types** (build vs runtime vs deployment)
- **User workflows** (development vs testing vs production)
- **Time patterns** (morning issues vs evening issues)

## ğŸ¯ ACTIONABLE MEMORY RULES

### Immediate Actions
Khi AI sees these triggers, AUTO-EXECUTE:

1. **"Can't connect to database"** â†’ Check connection string + env vars
2. **"Port already in use"** â†’ Run port kill script + restart service
3. **"Module not found"** â†’ Check imports + run yarn install
4. **"Build failed"** â†’ Run lint + fix TypeScript errors
5. **"Tests failing"** â†’ Update snapshots + check test data

### Preventive Actions
Based on past patterns, AUTO-SUGGEST:

1. **Before major changes** â†’ Run full test suite
2. **Before deployment** â†’ Check environment variables
3. **Before new features** â†’ Update documentation
4. **Before package updates** â†’ Check compatibility matrix
5. **Before refactoring** â†’ Create backup branch

## ğŸ”„ FEEDBACK LOOPS

### Success Metrics
Track effectiveness of memory patterns:
- **Reduced repetitive questions**
- **Faster problem resolution**
- **Fewer recurring bugs**
- **Improved code quality**
- **Higher user satisfaction**

### Memory Quality Indicators
- **Relevance**: ÄÆ°á»£c sá»­ dá»¥ng thÆ°á»ng xuyÃªn
- **Accuracy**: Giáº£i phÃ¡p work consistently
- **Completeness**: Enough detail to reproduce
- **Timeliness**: Still relevant for current tech stack
- **Clarity**: Easy to understand vÃ  apply
